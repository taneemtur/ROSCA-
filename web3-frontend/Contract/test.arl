archetype test(owner : address, totalRosca: tez, durationRosca: duration, maxUsers: nat)

//deployed contract url "https://better-call.dev/ghostnet/KT1F2PhjjBmKKECZULkWFNB1D2iGp4nGRwsp"

function is_not_paused() : bool {                                                         //returns true when rosca is not paused
  do_fail_if(paused, "CONTRACT_PAUSED");
  return true
}

function is_not_contributed(participant_address: address) : bool {                        //returns true when participant is not contributed
  do_fail_if(participant[participant_address].contributed, "ALREADY_CONTRIBUTED");
  return true
}

function is_all_contributed() : bool {                                                    //returns true when all participants are contributed
  for p in participant do
    do_require(participant[p].contributed,"NOT ALL CONTRIBUTED")
  done;
  return true
}

function is_all_received() : bool {                                                       //returns true when all participants are received
  for p in participant do
    do_require(participant[p].pot_received,"NOT ALL RECEIVED")
  done;
  return true
}

function is_contribution_ended(): bool{                                                   //returns true when contribution is ended
  const time ?= starting_time : "TIME ERROR";
  do_require(now>time+contributing_duration,"NOT YET");
  return true
}

function set_current_receiver() {                                                         //sets current receiver
  var ctrl : nat = 0;
  for p in participant do
    if(participant[p].pot_received)then begin
      ctrl += 1 //just does a thing, dont need to make sense
    end else begin
      receiver := some(p);
      receiver_setted := true;
    end
  done
}

function calculate_amount(): tez{                                                          //calculates the amount of payment per participant
  do_require(participants_count>0,"ANY PARTICIPANTS DOESNT EXIST");
  var rosca = mutez_to_nat(rosca_total);
  var rat = rosca/participants_count;
  var value = rat * 1utz;
  return value
}

//Pausable ---------------------------------------------------------------------
entry pause() {                                                                            //pauses the rosca process
  require {
    pausable_r1: is_not_paused() otherwise "ALREADY PAUSED"
  }
  effect {
    paused := true;
    emit<Paused>({now})
  }
}

entry unpause() {                                                                         //resumes the rosca process
  require {
    pausable_r2: paused otherwise "CONTRACT_NOT_PAUSED"
  }
  effect {
    paused := false;
    emit<Resumed>({now})
  }
}

//States ---------------------------------------------------------------------
states = 
|Starting
|Collecting initial
|Contributing
|Checking
|Setting_Receiver
|Distirbuting
|Distirbuted

//Storage---------------------------------------------------------------------
asset participant identified by p_address{                                                //participant struct
  id : nat ;
  p_address : address;
  contributed : bool ;
  pot_received : bool ;
}

variable rosca_total : tez = totalRosca
variable contributing_duration : duration = durationRosca
variable max_participants : nat = maxUsers

variable paused : bool = false
variable clock_started : bool = false
variable receiver_setted : bool = false

variable pot : tez = 0tz   
variable participants_count : nat = 0
variable contributors_count : nat = 0
variable contribute_amount : tez = 1tz
variable starting_time : option<date> = none
variable receiver : option<address> = none

//events ------------------------------------------------------------------------
event Joined{
  user : address;
  timestamp : date
}
event Contributed{
  user : address;
  timestamp : date
}
event ContributionStarted{
  timestamp : date
}
event Paused{
  timestamp : date
}
event Resumed{
  timestamp : date
}
//methods ------------------------------------------------------------------------
entry default() {}                                                                       //allows contract to give amounts

transition start(roscaTotal: tez, roscaDuration: duration , maxParticipants: nat ){      //starts rosca 
  called by owner
  state is Starting
  require {
    is_paused_r1: is_not_paused() otherwise "Rosca is Paused"
  }
  from Starting to Collecting
  with effect{
    rosca_total := roscaTotal;
    contributing_duration := roscaDuration;
    max_participants := maxParticipants;
  }
}

entry join(){                                                                              //allows participans to join rosca
  state is Collecting
  require {
      is_paused_r2: is_not_paused() otherwise "Rosca is Paused";
      join_r1: participants_count<=max_participants otherwise "Maximum number of participants reached."
  }
  fail if {
    c1: participant.contains(caller);
  }
  effect{
    participants_count += 1;
    participant.add({id = participants_count; p_address= caller; contributed=false; pot_received=false});
    emit<Joined>({caller; now})
  }
}

transition start_contributing (){                                                           //starts contirbuting section
  called by owner
  state is Collecting
  require {
    is_paused_r3: is_not_paused() otherwise "Rosca is Paused";
  }
  from Collecting to Contributing 
  with effect{
  starting_time := some(now);
  clock_started := true;
  emit<ContributionStarted>({now})
  }
}

entry contribute(){                                                                         //allows participants to contribute amount
  state is Contributing
  require {
    is_paused_r4: is_not_paused() otherwise "Rosca is Paused";
    contribute_r1: participant.contains(caller) otherwise "NOT PARTICIPANT";
    contribute_r2: is_not_contributed(caller) otherwise "Already Contributed";
    contribute_r3: transferred=calculate_amount() otherwise "PLEASE MAKE SURE TO SEND THE EXACT AMOUNT"
  }
  fail if {
    contribute_f1: is_contribution_ended()  with "Time is over"
  }
  effect{
    contributors_count +=1;
    participant.update(caller, {
      contributed = true
    });
    pot += transferred;
    emit<Contributed>({caller; now})
  }
}

transition end_contributing (){                                                             //ends contirbuting section
  called by owner
  state is Contributing
  require {
    is_paused_r5: is_not_paused() otherwise "Rosca is Paused";
    end_contributing_r1: is_contribution_ended()
  }
  from Contributing to Checking
  with effect{
  clock_started := false
  }
}

transition check() {                                                                        //checks participants and ban non contributors
  called by owner
  state is Checking
  require {
    is_paused_r6: is_not_paused() otherwise "Rosca is Paused";
  }
  from Checking to Setting_Receiver 
  with effect {
    var ctrl : nat = 0;
    for p in participant do
    if(participant[p].contributed) then begin //ban section
      ctrl +=1;
    end else begin
      participant.remove(p);
      participants_count -=1;
    end
    done;
  }
}

transition setReceiver() {                                                                  //sets receiver of pot
  called by owner
  state is Setting_Receiver
  require {
    is_paused_r7: is_not_paused() otherwise "Rosca is Paused";
  }
  from Setting_Receiver to Distirbuting
  with effect{
    set_current_receiver()
  }
}

transition disturbute() {                                                                   //distirbutes pot to receiver
  called by owner
  state is Distirbuting
  require {
    is_paused_r8: is_not_paused() otherwise "Rosca is Paused";
    disturbute_r1: pot>0tz otherwise "Pot is equal to zero";
  }
  from Distirbuting to Distirbuted
  with effect{
    const r ?= receiver : "RECEIVER IS NONE";
    pot := 0tz;
    participant.update(r, {
      pot_received = true
    });
    transfer balance to r;
    receiver_setted :=false;
    receiver := none;
  }
}

transition continue() {                                                                     //continues rosca and allow restart contribute section
  called by owner
  state is Distirbuted
  require {
    is_paused_r9: is_not_paused() otherwise "Rosca is Paused"; 
  }
  fail if{
    c3: is_all_received()
  }
  from Distirbuted to Contributing
  with effect {
    for p in participant do
    participant.update(p, {
      contributed = false
    });
    done;
    contributors_count := 0;
  }
}

transition reset(){                                                                        //resets rosca                                                                                 
  called by owner
  state is Distirbuted  
  require {
    reset_r1: is_all_received() otherwise "Not All Recevied"
  }
  from Distirbuted to Starting
  with effect{
    for p in participant do
      participant.remove(p);
    done;
  }
}

entry setRosca(amount: tez){
  do_require(caller=owner,"you are not the owner");
  rosca_total := amount;
}

//views --------------------------------------------------------------------
view show_balance() : tez {
  return balance
}

view show_conributing_cost() : tez{
  return calculate_amount()
}

view show_is_contribution_ended() : bool {
  return is_contribution_ended()
}

view show_currentState(): string {
  var currentState: string =  "";
  match state with
  |Starting -> currentState := "Starting"
  |Collecting -> currentState := "Collecting"
  |Contributing -> currentState := "Contributing"
  |Checking -> currentState := "Checking"
  |Setting_Receiver -> currentState := "Setting_Receiver"
  |Distirbuting -> currentState := "Distirbuting"
  |Distirbuted -> currentState := "Distirbuted"
  end;
  return currentState
}

view show_receiver(): address {
  const r ?= receiver : "RECEIVER IS NONE";
  return r
}

view show_isAllContributed(): bool {
  var result =  is_all_contributed();
  return result
}

view show_isAllReceived(): bool {
  var result =  is_all_received();
  return result
}

view show_participant(participant_address : address): option<asset_value<participant>>{
 const a: option<asset_value<participant>> = participant[participant_address];
 return a
}