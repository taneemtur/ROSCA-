archetype test
/* PAUSABLE ---------------------------------------------------------------- */

variable paused : bool = false

function is_not_paused() : bool {
  do_fail_if(paused, "CONTRACT_PAUSED");
  return true
}

function is_not_contributed(participant_address: address) : bool {
  do_fail_if(participant[participant_address].contributed, "ALREADY_CONTRIBUTED");
  return true
}

function is_all_contributed() : bool {
  for p in participant do
    do_require(participant[p].contributed,"NOT ALL CONTRIBUTED")
  done;
  return true
}

function is_all_received() : bool {
  for p in participant do
    do_require(participant[p].pot_received,"NOT ALL RECEIVED")
  done;
  return true
}

function set_current_receiver() { 
  var ctrl : nat = 0;
  for p in participant do
    if(participant[p].pot_received)then begin
      ctrl += 1 //just does a thing, dont need to make sense
    end else begin
      receiver := some(p);
      receiver_setted := true;
    end
  done
}

entry pause() {
  require {
    pausable_r1: is_not_paused()
  }
  effect {
    paused := true
  }
}

entry unpause() {
  require {
    pausable_r2: paused otherwise "CONTRACT_NOT_PAUSED"
  }
  effect {
    paused := false
  }
}

//Storage---------------------------------------------------------------------
asset participant identified by p_address{
  p_address : address;
  id : nat ;
  contributed : bool ;
  pot_received : bool ;
  penalty_points : int ;
}

variable participants_count : nat = 0
variable max_participants : nat = 10
variable pot : tez = 0tz    
variable distirbuted : bool = false
variable receiver_setted : bool = false
variable receiver : option<address> = none //burn address
              

//methods------------------------------------------------------------------------
entry join(new_participant : address){
  require {
      r1: is_not_paused();
      r2: participants_count<max_participants;
  }
  fail if {
    c1: participant.contains(new_participant)
  }
  effect{
    participants_count += 1;
    participant.add({id = participants_count; p_address= new_participant; contributed=false; pot_received=false; penalty_points=0});
  }
}

entry contribute(participant_address : address, amount: tez){
  require {
      r3: is_not_paused();
      r4: participant.contains(participant_address);
      r5: is_not_contributed(participant_address);
  }
  effect{
    participant.update(participant_address, {
      contributed = true
    });
    pot += amount;
    
  }
}

entry set_receiver() {
  require {
    r6: is_all_contributed();
  }
  effect{
    set_current_receiver()
  }
}

entry disturbute() {
  require {
    r7: is_not_paused();
    r8: pot>0tz;
    r9: receiver_setted;
  }
  effect{
    const r ?= receiver : "RECEIVER IS NONE";
    distirbuted := true;
    pot := 0tz;
    participant.update(r, {
      pot_received = true
    });
    for p in participant do
    participant.update(p, {
      contributed = false
    });
    receiver_setted :=false;
    done;
  }
}

entry reset() {
  require {
    r10: is_all_received(); 
  }
  effect {
    for p in participant do
    participant[p].contributed := false;
    participant[p].pot_received := false;
    done;
    pot := 0tz;
    distirbuted := false;
    receiver_setted :=false;
    receiver := none //burn address
  }
}

view show_distirbuted() : bool{
  return distirbuted
}

view show_participantsCount(): nat {
  return participants_count
}

view show_pot(): tez {
  return pot
}

view show_receiver(): address {
  const r ?= receiver : "RECEIVER IS NONE";
  return r
}

view show_participant(participant_address : address): option<asset_value<participant>>{
 const a: option<asset_value<participant>> = participant[participant_address];
 return a
}