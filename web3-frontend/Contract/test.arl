archetype test
//deployed contract url "https://better-call.dev/ghostnet/KT1XAvmvqGVKjhsyq92ZzKsRWDaRdf43SmRJ/interact/check"

function is_not_paused() : bool {                                                         //returns true when rosca is not paused
  do_fail_if(paused, "CONTRACT_PAUSED");
  return true
}

function is_not_contributed(participant_address: address) : bool {                        //returns true when participant is not contributed
  do_fail_if(participant[participant_address].contributed, "ALREADY_CONTRIBUTED");
  return true
}

function is_all_contributed() : bool {                                                    //returns true when all participants are contributed
  for p in participant do
    do_require(participant[p].contributed,"NOT ALL CONTRIBUTED")
  done;
  return true
}

function is_all_received() : bool {                                                       //returns true when all participants are received
  for p in participant do
    do_require(participant[p].pot_received,"NOT ALL RECEIVED")
  done;
  return true
}

function is_contribution_ended(): bool{                                                   //returns true when contribution is ended
  const time ?= starting_time : "TIME ERROR";
  do_require(now>time+contributing_duration,"NOT YET");
  return true
}

function set_current_receiver() {                                                         //sets current receiver
  var ctrl : nat = 0;
  for p in participant do
    if(participant[p].pot_received)then begin
      ctrl += 1 //just does a thing, dont need to make sense
    end else begin
      receiver := some(p);
      receiver_setted := true;
    end
  done
}

function calculate_amount(): tez{                                                          //calculates the amount of payment per participant
  do_require(participants_count>0,"ANY PARTICIPANTS DOESNT EXIST");
  var rosca = mutez_to_nat(rosca_total);
  var rat = rosca/participants_count;
  var value = rat * 1utz;
  return value
}

//Pausable ---------------------------------------------------------------------
entry pause() {                                                                            //pauses the rosca process
  require {
    pausable_r1: is_not_paused() otherwise "ALREADY PAUSED"
  }
  effect {
    paused := true
  }
}

entry unpause() {                                                                         //resumes the rosca process
  require {
    pausable_r2: paused otherwise "CONTRACT_NOT_PAUSED"
  }
  effect {
    paused := false
  }
}

//States ---------------------------------------------------------------------
states = 
|Starting
|Collecting initial
|Contributing
|Checking
|Setting_Receiver
|Distirbuting
|Distirbuted

//Storage---------------------------------------------------------------------
asset participant identified by p_address{                                                //participant struct
  id : nat ;
  p_address : address;
  contributed : bool ;
  pot_received : bool ;
}

variable rosca_total : tez = 2tz
variable contributing_duration : duration = 1m
variable max_participants : nat = 10

variable paused : bool = false
variable clock_started : bool = false
variable receiver_setted : bool = false

variable pot : tez = 0tz   
variable participants_count : nat = 0
variable contributors_count : nat = 0
variable contribute_amount : tez = 1tz
variable starting_time : option<date> = none
variable receiver : option<address> = none

variable tried : bool = false
//methods------------------------------------------------------------------------
entry default() {}                                                                       //allows contract to give amounts

transition start(roscaTotal: tez, roscaDuration: duration , maxParticipants: nat ){      //starts rosca 
  state is Starting
  require {
    is_paused_r1: is_not_paused() otherwise "Rosca is Paused"
  }
  from Starting to Collecting
  with effect{
    rosca_total := roscaTotal;
    contributing_duration := roscaDuration;
    max_participants := maxParticipants;
  }
}

entry join(){                                                                              //allows participans to join rosca
  state is Collecting
  require {
      is_paused_r2: is_not_paused() otherwise "Rosca is Paused";
      join_r1: participants_count<=max_participants otherwise "Maximum number of participants reached."
  }
  fail if {
    c1: participant.contains(caller);
  }
  effect{
    participants_count += 1;
    participant.add({id = participants_count; p_address= caller; contributed=false; pot_received=false});
  }
}

transition start_contributing (){                                                           //starts contirbuting section
  state is Collecting
  require {
    is_paused_r3: is_not_paused() otherwise "Rosca is Paused";
  }
  from Collecting to Contributing 
  with effect{
  starting_time := some(now);
  clock_started := true
  }
}

entry contribute(){                                                                         //allows participants to contribute amount
  state is Contributing
  require {
    is_paused_r4: is_not_paused() otherwise "Rosca is Paused";
    contribute_r1: participant.contains(caller) otherwise "NOT PARTICIPANT";
    contribute_r2: is_not_contributed(caller) otherwise "Already Contributed";
    contribute_r3: transferred=calculate_amount() otherwise "PLEASE MAKE SURE TO SEND THE EXACT AMOUNT"
  }
  effect{
    contributors_count +=1;
    participant.update(caller, {
      contributed = true
    });
    pot += transferred;
  }
}

transition end_contributing (){                                                             //ends contirbuting section
  state is Contributing
  require {
    is_paused_r5: is_not_paused() otherwise "Rosca is Paused";
    end_contributing_r1: is_contribution_ended()
  }
  from Contributing to Checking
  with effect{
  clock_started := false
  }
}

transition check() {                                                                        //checks participants and ban non contributors
  state is Checking
  require {
    is_paused_r6: is_not_paused() otherwise "Rosca is Paused";
  }
  from Checking to Setting_Receiver 
  with effect {
    var ctrl : nat = 0;
    for p in participant do
    if(participant[p].contributed) then begin //ban section
      ctrl +=1;
    end else begin
      participant.remove(p);
      participants_count -=1;
    end
    done;
  }
}

transition setReceiver() {                                                                  //sets receiver of pot
  state is Setting_Receiver
  require {
    is_paused_r7: is_not_paused() otherwise "Rosca is Paused";
  }
  from Setting_Receiver to Distirbuting
  with effect{
    set_current_receiver()
  }
}

entry try(){
  const time ?= starting_time : "TIME ERROR";
  do_require(now>time+30s,"NOT YET");
  tried := true
}

transition disturbute() {                                                                   //distirbutes pot to receiver
  state is Distirbuting
  require {
    is_paused_r8: is_not_paused() otherwise "Rosca is Paused";
    disturbute_r1: pot>0tz otherwise "Pot is equal to zero";
  }
  from Distirbuting to Distirbuted
  with effect{
    const r ?= receiver : "RECEIVER IS NONE";
    pot := 0tz;
    participant.update(r, {
      pot_received = true
    });
    transfer balance to r;
    receiver_setted :=false;
    receiver := none;
  }
}

transition continue() {                                                                     //continues rosca and allow restart contribute section
  state is Distirbuted
  require {
    is_paused_r9: is_not_paused() otherwise "Rosca is Paused"; 
  }
  fail if{
    c3: is_all_received()
  }
  from Distirbuted to Contributing
  with effect {
    for p in participant do
    participant.update(p, {
      contributed = false
    });
    done;
    contributors_count := 0;
  }
}

transition reset(){                                                                        //finihes rosca                                                                                 
  state is Distirbuted  
  require {
    reset_r1: is_all_received() otherwise "Not All Recevied"
  }
  from Distirbuted to Starting
  with effect{
    for p in participant do
      participant.remove(p);
    done;
    rosca_total := 2tz;
    max_participants := 2;
    contributing_duration := 1m;
  }
}

entry setRosca(amount: tez){
  rosca_total := amount;
}

//views --------------------------------------------------------------------
view show_balance() : tez {
  return balance
}

view show_conributing_cost() : tez{
  return calculate_amount()
}

view show_is_contribution_ended() : bool {
  return is_contribution_ended()
}

view show_clock_started() : bool{
  return clock_started
}

view show_starting_time() : option<date>{
  return starting_time
}

view show_participantsCount(): nat {
  return participants_count
}

view show_contributors_count(): nat {
  return contributors_count
}

view show_pot(): tez {
  return pot
}

view show_currentState(): string {
  var currentState: string =  "";
  match state with
  |Starting -> currentState := "Starting"
  |Collecting -> currentState := "Collecting"
  |Contributing -> currentState := "Contributing"
  |Checking -> currentState := "Checking"
  |Setting_Receiver -> currentState := "Setting_Receiver"
  |Distirbuting -> currentState := "Distirbuting"
  |Distirbuted -> currentState := "Distirbuted"
  end;
  return currentState
}

view show_receiver(): address {
  const r ?= receiver : "RECEIVER IS NONE";
  return r
}

view show_isAllContributed(): bool {
  var result =  is_all_contributed();
  return result
}

view show_isAllReceived(): bool {
  var result =  is_all_received();
  return result
}

view show_participant(participant_address : address): option<asset_value<participant>>{
 const a: option<asset_value<participant>> = participant[participant_address];
 return a
}