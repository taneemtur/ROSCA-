archetype test
//deployed contract url https://better-call.dev/ghostnet/KT1XHeyfURDktA68V8hGQV4SYaBBWHwKxAn6
function is_not_paused() : bool {
  do_fail_if(paused, "CONTRACT_PAUSED");
  return true
}

function is_not_contributed(participant_address: address) : bool {
  do_fail_if(participant[participant_address].contributed, "ALREADY_CONTRIBUTED");
  return true
}

function is_all_contributed() : bool {
  for p in participant do
    do_require(participant[p].contributed,"NOT ALL CONTRIBUTED")
  done;
  return true
}

function is_all_received() : bool {
  for p in participant do
    do_require(participant[p].pot_received,"NOT ALL RECEIVED")
  done;
  return true
}

function set_current_receiver() { 
  var ctrl : nat = 0;
  for p in participant do
    if(participant[p].pot_received)then begin
      ctrl += 1 //just does a thing, dont need to make sense
    end else begin
      receiver := some(p);
      receiver_setted := true;
    end
  done
}

function is_time_passed(): bool{
  const time ?= starting_time : "TIME ERROR";
  do_require(now>time+dur,"NOT YET");
  return true
}

function calculate_amount(): tez{
  do_require(started, "NOT STARTED YET");
  do_fail_if(contributors_count=0,"ANY CONTRIBUTORS DOESNT EXIST");
  var rosca = mutez_to_nat(rosca_total);
  var rat = rosca/contributors_count;
  var value = rat * 1tz;
  return value
}
//Pausable ---------------------------------------------------------------------
entry pause() {
  require {
    pausable_r1: is_not_paused()
  }
  effect {
    paused := true
  }
}

entry unpause() {
  require {
    pausable_r2: paused otherwise "CONTRACT_NOT_PAUSED"
  }
  effect {
    paused := false
  }
}

//Storage---------------------------------------------------------------------
asset participant identified by p_address{
  id : nat ;
  p_address : address;
  contributed : bool ;
  pot_received : bool ;
  penalty_points : nat ;
}
variable rosca_total : tez =10tz
variable paused : bool = false
variable started : bool = false
variable starting_time : option<date> = none
variable dur : duration = 3m
variable participants_count : nat = 0
variable contributors_count : nat = 0
variable max_participants : nat = 10
variable pot : tez = 0tz    
variable distirbuted : bool = false
variable receiver_setted : bool = false
variable receiver : option<address> = none
variable tried : bool = false
variable contribute_amount : tez = 1tz
              

//methods------------------------------------------------------------------------
entry join(new_participant : address){
  require {
      r1: is_not_paused();
      r2: participants_count<max_participants;
  }
  fail if {
    c1: participant.contains(new_participant);
    c2: started
  }
  effect{
    participants_count += 1;
    participant.add({id = participants_count; p_address= new_participant; contributed=false; pot_received=false; penalty_points=0});
  }
}

entry start (){
  starting_time := some(now);
  started := true
}

entry default() {}

entry contribute(participant_address : address, amount: tez){
  require {
      r3: is_not_paused() otherwise "PAUSED";
      r4: participant.contains(participant_address) otherwise "NOT PARTICIPANT";
      r5: is_not_contributed(participant_address) otherwise "NOT CONTRIBUTED";
      r6: started otherwise "NOT STARTED";
      r15: amount=calculate_amount() otherwise "PLEASE MAKE SURE TO SEND THE RIGHT AMOUNT"
  }
  effect{
    contributors_count +=1;
    participant.update(participant_address, {
      contributed = true
    });
    pot += amount;
  }
}

// entry collect(collector : address) {
//   effect {
//     caller.transfer balance to collector
//   }
// }

entry setReceiver() {
  require {
    r7: started
  }
  effect{
    set_current_receiver()
  }
}
entry try(){
  const time ?= starting_time : "TIME ERROR";
  do_require(now>time+30s,"NOT YET");
  tried := true
}

entry disturbute() {
  require {
    r8: started;
    r9: is_not_paused();
    r10: pot>0tz;
    r11: receiver_setted;
    r12: is_time_passed();
  }
  effect{
    var ctrl : nat = 0;
    const r ?= receiver : "RECEIVER IS NONE";
    distirbuted := true;
    pot := 0tz;
    if(participant[r].contributed)then begin
      ctrl +=1;
    end else begin
      participant.remove(r);
      do_require(participant[r].contributed,"PARTICIPANT BANNED. SET ANOTHER RECEIVER.")
    end;
    participant.update(r, {
      pot_received = true
    });
    for p in participant do
    participant.update(p, {
      contributed = false
    });
    done;
    receiver_setted :=false;
    receiver := none;
    started := false
  }
}

entry reset() {
  require {
    r14: is_all_received(); 
  }
  effect {
    for p in participant do
    participant[p].contributed := false;
    participant[p].pot_received := false;
    done;
    pot := 0tz;
    distirbuted := false;
    receiver_setted :=false;
    receiver := none
  }
}

entry setRosca(amount: tez){
  rosca_total := amount;
}

//views --------------------------------------------------------------------
view show_balance() : tez {
  return balance
}

view show_conribute_cost() : tez{
  return calculate_amount()
}

view show_is_time_passed() : bool {
  return is_time_passed()
}

view show_distirbuted() : bool{
  return distirbuted
}

view show_started() : bool{
  return started
}

view show_starting_time() : option<date>{
  return starting_time
}

view show_participantsCount(): nat {
  return participants_count
}

view show_pot(): tez {
  return pot
}

view show_receiver(): address {
  const r ?= receiver : "RECEIVER IS NONE";
  return r
}

view show_isAllContributed(): bool {
  var result =  is_all_contributed();
  return result
}

view show_isAllReceived(): bool {
  var result =  is_all_received();
  return result
}

view show_participant(participant_address : address): option<asset_value<participant>>{
 const a: option<asset_value<participant>> = participant[participant_address];
 return a
}